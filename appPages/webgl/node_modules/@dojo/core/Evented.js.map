{"version":3,"file":"Evented.js","sourceRoot":"","sources":["Evented.ts"],"names":[],"mappings":";;;;;;;;;;;;IAAA,sCAAiC;IAEjC,mCAA0C;IAC1C,6CAA4C;IAE5C;;;;;OAKG;IACH,8BAA8B,OAAiB;QAC9C,MAAM,CAAC;YACN,OAAO;gBACN,OAAO,CAAC,OAAO,CAAC,UAAC,MAAM,IAAK,OAAA,MAAM,CAAC,OAAO,EAAE,EAAhB,CAAgB,CAAC,CAAC;YAC/C,CAAC;SACD,CAAC;IACH,CAAC;IAED;;OAEG;IACH,IAAM,QAAQ,GAAG,IAAI,aAAG,EAAkB,CAAC;IAE3C;;;;OAIG;IACH,qBAA4B,UAA2B,EAAE,YAA6B;QACrF,EAAE,CAAC,CAAC,OAAO,YAAY,KAAK,QAAQ,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAC1G,IAAI,KAAK,SAAQ,CAAC;YAClB,EAAE,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC9B,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC;YACnC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACP,KAAK,GAAG,IAAI,MAAM,CAAC,MAAI,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,MAAG,CAAC,CAAC;gBAC3D,QAAQ,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YACjC,CAAC;YACD,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACjC,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,MAAM,CAAC,UAAU,KAAK,YAAY,CAAC;QACpC,CAAC;IACF,CAAC;IAbD,kCAaC;IAqBD;;OAEG;IACH;QAA0G,mCAAW;QAArH;YAAA,qEAwDC;YAjDA;;eAEG;YACO,kBAAY,GAAmF,IAAI,aAAG,EAAE,CAAC;;QA8CpH,CAAC;QArCA,sBAAI,GAAJ,UAAK,KAAU;YAAf,iBAOC;YANA,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,IAAI;gBACtC,kHAAkH;gBAClH,EAAE,CAAC,CAAC,WAAW,CAAC,IAAW,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC1C,MAAM,CAAC,IAAI,CAAC,KAAI,EAAE,KAAK,CAAC,CAAC;gBAC1B,CAAC;YACF,CAAC,CAAC,CAAC;QACJ,CAAC;QAsBD,oBAAE,GAAF,UAAG,IAAS,EAAE,QAA0C;YAAxD,iBAOC;YANA,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC7B,IAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAC,QAAQ,IAAK,OAAA,WAAQ,CAAC,KAAI,CAAC,YAAY,EAAE,IAAI,EAAE,QAAQ,CAAC,EAA3C,CAA2C,CAAC,CAAC;gBACxF,MAAM,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;YACtC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACP,MAAM,CAAC,WAAQ,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;YACpD,CAAC;QACF,CAAC;QACF,cAAC;IAAD,CAAC,AAxDD,CAA0G,yBAAW,GAwDpH;IAxDY,0BAAO;IA0DpB,kBAAe,OAAO,CAAC","sourcesContent":["import Map from '@dojo/shim/Map';\nimport { Handle, EventType, EventObject } from './interfaces';\nimport { on as aspectOn } from './aspect';\nimport { Destroyable } from './Destroyable';\n\n/**\n * Handles an array of handles\n *\n * @param handles an array of handles\n * @returns a single Handle for handles passed\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\n/**\n * Map of computed regular expressions, keyed by string\n */\nconst regexMap = new Map<string, RegExp>();\n\n/**\n * Determines is the event type glob has been matched\n *\n * @returns boolean that indicates if the glob is matched\n */\nexport function isGlobMatch(globString: string | symbol, targetString: string | symbol): boolean {\n\tif (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {\n\t\tlet regex: RegExp;\n\t\tif (regexMap.has(globString)) {\n\t\t\tregex = regexMap.get(globString)!;\n\t\t} else {\n\t\t\tregex = new RegExp(`^${globString.replace(/\\*/g, '.*')}$`);\n\t\t\tregexMap.set(globString, regex);\n\t\t}\n\t\treturn regex.test(targetString);\n\t} else {\n\t\treturn globString === targetString;\n\t}\n}\n\nexport type EventedCallback<T = EventType, E extends EventObject<T> = EventObject<T>> = {\n\t/**\n\t * A callback that takes an `event` argument\n\t *\n\t * @param event The event object\n\t */\n\n\t(event: E): boolean | void;\n};\n\n/**\n * A type which is either a targeted event listener or an array of listeners\n * @template T The type of target for the events\n * @template E The event type for the events\n */\nexport type EventedCallbackOrArray<T = EventType, E extends EventObject<T> = EventObject<T>> =\n\t| EventedCallback<T, E>\n\t| EventedCallback<T, E>[];\n\n/**\n * Event Class\n */\nexport class Evented<M extends {} = {}, T = EventType, O extends EventObject<T> = EventObject<T>> extends Destroyable {\n\t// The following member is purely so TypeScript remembers the type of `M` when extending so\n\t// that the utilities in `on.ts` will work\n\t// https://github.com/Microsoft/TypeScript/issues/20348\n\t// tslint:disable-next-line\n\tprotected __typeMap__?: M;\n\n\t/**\n\t * map of listeners keyed by event type\n\t */\n\tprotected listenersMap: Map<T | keyof M, EventedCallback<T, O> | EventedCallback<keyof M, M[keyof M]>> = new Map();\n\n\t/**\n\t * Emits the event objet for the specified type\n\t *\n\t * @param event the event to emit\n\t */\n\temit<K extends keyof M>(event: M[K]): void;\n\temit(event: O): void;\n\temit(event: any): void {\n\t\tthis.listenersMap.forEach((method, type) => {\n\t\t\t// Since `type` is generic, the compiler doesn't know what type it is and `isGlobMatch` requires `string | symbol`\n\t\t\tif (isGlobMatch(type as any, event.type)) {\n\t\t\t\tmethod.call(this, event);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Catch all handler for various call signatures. The signatures are defined in\n\t * `BaseEventedEvents`.  You can add your own event type -> handler types by extending\n\t * `BaseEventedEvents`.  See example for details.\n\t *\n\t * @param args\n\t *\n\t * @example\n\t *\n\t * interface WidgetBaseEvents extends BaseEventedEvents {\n\t *     (type: 'properties:changed', handler: PropertiesChangedHandler): Handle;\n\t * }\n\t * class WidgetBase extends Evented {\n\t *    on: WidgetBaseEvents;\n\t * }\n\t *\n\t * @return {any}\n\t */\n\ton<K extends keyof M>(type: K, listener: EventedCallbackOrArray<K, M[K]>): Handle;\n\ton(type: T, listener: EventedCallbackOrArray<T, O>): Handle;\n\ton(type: any, listener: EventedCallbackOrArray<any, any>): Handle {\n\t\tif (Array.isArray(listener)) {\n\t\t\tconst handles = listener.map((listener) => aspectOn(this.listenersMap, type, listener));\n\t\t\treturn handlesArraytoHandle(handles);\n\t\t} else {\n\t\t\treturn aspectOn(this.listenersMap, type, listener);\n\t\t}\n\t}\n}\n\nexport default Evented;\n"]}