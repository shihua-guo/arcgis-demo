{"version":3,"file":"Evented.mjs","sourceRoot":"","sources":["../../src/Evented.ts"],"names":[],"mappings":"AAAA,OAAO,GAAG,MAAM,gBAAgB,CAAC;AAEjC,OAAO,EAAE,EAAE,IAAI,QAAQ,EAAE,MAAM,UAAU,CAAC;AAC1C,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAE5C;;;;;GAKG;AACH,8BAA8B,OAAiB;IAC9C,MAAM,CAAC;QACN,OAAO;YACN,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC;QAC/C,CAAC;KACD,CAAC;AACH,CAAC;AAED;;GAEG;AACH,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAkB,CAAC;AAE3C;;;;GAIG;AACH,MAAM,sBAAsB,UAA2B,EAAE,YAA6B;IACrF,EAAE,CAAC,CAAC,OAAO,YAAY,KAAK,QAAQ,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1G,IAAI,KAAa,CAAC;QAClB,EAAE,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9B,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC;QACnC,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;YAC3D,QAAQ,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;QACjC,CAAC;QACD,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACjC,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,MAAM,CAAC,UAAU,KAAK,YAAY,CAAC;IACpC,CAAC;AACF,CAAC;AAqBD;;GAEG;AACH,MAAM,cAA4F,SAAQ,WAAW;IAArH;;QAOC;;WAEG;QACO,iBAAY,GAAmF,IAAI,GAAG,EAAE,CAAC;IA8CpH,CAAC;IArCA,IAAI,CAAC,KAAU;QACd,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;YAC1C,kHAAkH;YAClH,EAAE,CAAC,CAAC,WAAW,CAAC,IAAW,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC1B,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAsBD,EAAE,CAAC,IAAS,EAAE,QAA0C;QACvD,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;YACxF,MAAM,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACtC,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpD,CAAC;IACF,CAAC;CACD;AAED,eAAe,OAAO,CAAC","sourcesContent":["import Map from '@dojo/shim/Map';\nimport { Handle, EventType, EventObject } from './interfaces';\nimport { on as aspectOn } from './aspect';\nimport { Destroyable } from './Destroyable';\n\n/**\n * Handles an array of handles\n *\n * @param handles an array of handles\n * @returns a single Handle for handles passed\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\n/**\n * Map of computed regular expressions, keyed by string\n */\nconst regexMap = new Map<string, RegExp>();\n\n/**\n * Determines is the event type glob has been matched\n *\n * @returns boolean that indicates if the glob is matched\n */\nexport function isGlobMatch(globString: string | symbol, targetString: string | symbol): boolean {\n\tif (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {\n\t\tlet regex: RegExp;\n\t\tif (regexMap.has(globString)) {\n\t\t\tregex = regexMap.get(globString)!;\n\t\t} else {\n\t\t\tregex = new RegExp(`^${globString.replace(/\\*/g, '.*')}$`);\n\t\t\tregexMap.set(globString, regex);\n\t\t}\n\t\treturn regex.test(targetString);\n\t} else {\n\t\treturn globString === targetString;\n\t}\n}\n\nexport type EventedCallback<T = EventType, E extends EventObject<T> = EventObject<T>> = {\n\t/**\n\t * A callback that takes an `event` argument\n\t *\n\t * @param event The event object\n\t */\n\n\t(event: E): boolean | void;\n};\n\n/**\n * A type which is either a targeted event listener or an array of listeners\n * @template T The type of target for the events\n * @template E The event type for the events\n */\nexport type EventedCallbackOrArray<T = EventType, E extends EventObject<T> = EventObject<T>> =\n\t| EventedCallback<T, E>\n\t| EventedCallback<T, E>[];\n\n/**\n * Event Class\n */\nexport class Evented<M extends {} = {}, T = EventType, O extends EventObject<T> = EventObject<T>> extends Destroyable {\n\t// The following member is purely so TypeScript remembers the type of `M` when extending so\n\t// that the utilities in `on.ts` will work\n\t// https://github.com/Microsoft/TypeScript/issues/20348\n\t// tslint:disable-next-line\n\tprotected __typeMap__?: M;\n\n\t/**\n\t * map of listeners keyed by event type\n\t */\n\tprotected listenersMap: Map<T | keyof M, EventedCallback<T, O> | EventedCallback<keyof M, M[keyof M]>> = new Map();\n\n\t/**\n\t * Emits the event objet for the specified type\n\t *\n\t * @param event the event to emit\n\t */\n\temit<K extends keyof M>(event: M[K]): void;\n\temit(event: O): void;\n\temit(event: any): void {\n\t\tthis.listenersMap.forEach((method, type) => {\n\t\t\t// Since `type` is generic, the compiler doesn't know what type it is and `isGlobMatch` requires `string | symbol`\n\t\t\tif (isGlobMatch(type as any, event.type)) {\n\t\t\t\tmethod.call(this, event);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Catch all handler for various call signatures. The signatures are defined in\n\t * `BaseEventedEvents`.  You can add your own event type -> handler types by extending\n\t * `BaseEventedEvents`.  See example for details.\n\t *\n\t * @param args\n\t *\n\t * @example\n\t *\n\t * interface WidgetBaseEvents extends BaseEventedEvents {\n\t *     (type: 'properties:changed', handler: PropertiesChangedHandler): Handle;\n\t * }\n\t * class WidgetBase extends Evented {\n\t *    on: WidgetBaseEvents;\n\t * }\n\t *\n\t * @return {any}\n\t */\n\ton<K extends keyof M>(type: K, listener: EventedCallbackOrArray<K, M[K]>): Handle;\n\ton(type: T, listener: EventedCallbackOrArray<T, O>): Handle;\n\ton(type: any, listener: EventedCallbackOrArray<any, any>): Handle {\n\t\tif (Array.isArray(listener)) {\n\t\t\tconst handles = listener.map((listener) => aspectOn(this.listenersMap, type, listener));\n\t\t\treturn handlesArraytoHandle(handles);\n\t\t} else {\n\t\t\treturn aspectOn(this.listenersMap, type, listener);\n\t\t}\n\t}\n}\n\nexport default Evented;\n"]}